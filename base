#For循环:

for letter in 'Python':
for index in range(len(fruits)):
for else for 结束的时候进入else


#Set 部分:

s = set()
s.add("1")
s.add("2")

print s  # 1, 2

是否含有
x in set


#其他
没有 自增加
j= j+1


list 的方法:
全部都需要记住!!!
insert
append
pop
1. pop  + index
2. pop 顶点
remove
1. remove 根据值来.
等等

队列:
pop(0)
append()

栈
pop() 最后
append() 最后

统计list 中出现的内容
list.count(obj)


数组切片:
1. nums[start:stop:step]
   print nums[:3:]
   print nums[3::]
   print nums[::3]


insert 用法 . 永远插头. 后面自己往后放.
class Solution:
    # 返回从尾部到头部的列表值序列，例如[1,2,3]
    def printListFromTailToHead(self, listNode):
        # write code here
        l = []
        head = listNode
        while head:
            l.insert(0, head.val)
            head = head.next
        return l


交换两个数
nums[i], nums[j] = nums[j], nums[i]

从当前开始减少到0 结束
for j in range(i - 1, -1, -1):


直接遍历 index + obj
for i, v in enumerate(array, start=0):
start=1  下标从1 开始数


list 转 str
str_convert = ''.join(list)
str 转 list
result = [character for character in string]


[1,2,3,4] ---> 1234
int(''.join([str(x) for x in a]))


sort + lambada 表达式.进行对比.


self.pathTmp = [False for i in range(n)]

二维数组初始化:
dp = [[0 for i in range(n)] for j in range(m)]

翻转:
list.reverse()
lst3 = lst[::-1]
lst1 = [i for i in reversed(lst)]
lst2 = sorted(lst,reverse=True)